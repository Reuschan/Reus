<!DOCTYPE html>
<html>

<head>
   <title>练习专用</title>
   <meta charset="utf-8">
</head>
<body>
<script type="text/javascript">
/*function box(){
	var sum=0;
	for(var i=0;i<arguments.length;i++){
		sum=sum+arguments[i];

	}
return sum;


}

alert(box(1,2,3,4,5,6,7,89));*/



/*var test=(function(a){
    this.a=a;
    return function(b){
    	 return this.a+b;
    }

  }(function(a,b){
  	  return a;
  }(1,2)));

console.log(test(4));*/


/*function box(num){

	if(num<=1){
		return 1;
	}else{
		return num*box(num-1);  //一个简单的递归
	}
}	

alert(box(6));*/    //6*5*4*3*2*1=720 


/*当函数名box改变的时候，内部自身调用的也要修改，比较麻烦        
下面的例子用arguments.callee来代替内部自身调用的函数名
function box(num){
	if(num<=1){
		return 1;
	}else{
		return num*arguments.callee(num-1); //使用callee来执行自身
	}
}

alert(box(6));*/


/*Array.prototype.copy=function(){
	var sub=this.concat(this);    //concat方法用来连接两个数组
	return sub;
}

var a=['a','b',3,4,5];

console.log(a.copy());

function box(){
	var sum=0;
	for(var i=0;i<arguments.length;i++){
		sum=sum+arguments[i];

	}
return sum;


}

var num=Number((10));
alert(box(num,num));*/



/*function aaa(){
	var a = 1;
	function bbb(){
      console.log(a++);
	};
	return bbb;
}

var result = aaa();
result();
result();
result();
result();
result();
result=null;*/

/*function f1(){
	var n = 999;
	function f2(){
		console.log(n);
	}
    return f2;
}

var obj = f1();
obj();*/

/*function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(1000).then((value) => {
  console.log(value);
});*/


/*function summation(){
	//把具有length属性的对象转换成数组
	var list = Array.prototype.slice.call(arguments),
	    result = {total:0,
	              average:0 
	    };
	list.forEach(function sum(value){
		result.total += value;
	});

	result.average = result.total / list.length;
    
	return result;    
}

console.log(summation(1,2,3,4,5));*/

</script>



</body>
</html>
  

 